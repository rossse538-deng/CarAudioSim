<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ËΩ¶ËΩΩÈ´òÈü≥‰ªøÁúü V13.5 - Âú®Á∫øÁâà</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
        
        #header {
            position: absolute; top: 0; left: 0; width: 100%; height: 36px;
            background: #0f0f12; border-bottom: 1px solid #333;
            display: flex; align-items: center; padding: 0 15px;
            color: #666; z-index: 10; font-size: 11px;
            justify-content: space-between;
        }
        .brand-group { display: flex; align-items: center; }
        .version-tag { background:#ff0000; color:#fff; padding:1px 5px; border-radius:2px; margin-left:8px; font-weight:bold; }

        .header-btns { display: flex; gap: 10px; }
        .btn-tool {
            cursor: pointer; background: #222; color: #ccc; padding: 3px 10px; 
            border-radius: 3px; border: 1px solid #444; font-size: 11px; pointer-events: auto;
            transition: 0.2s; display: flex; align-items: center;
        }
        .btn-tool:hover { background: #444; color: #fff; border-color: #666; }
        .btn-active { background: #225522 !important; border-color: #44ff44 !important; color: #fff !important; }

        /* HUD ‰ª™Ë°®Áõò */
        #hud-dashboard {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 600px; height: auto;
            background: rgba(18, 18, 22, 0.95);
            border: 1px solid #444; border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            backdrop-filter: blur(12px);
            display: flex; overflow: hidden;
            pointer-events: none; z-index: 20;
        }
        @media (max-width: 700px) {
            #hud-dashboard { width: 95%; top: 40px; transform: translateX(-50%) scale(0.8); transform-origin: top center; }
            #ui-panel { transform: scale(0.9); transform-origin: top right; top: 180px; }
        }

        .grade-section {
            width: 120px; display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            background: rgba(255,255,255,0.03);
            border-right: 1px solid #333; padding: 10px;
        }
        .grade-title { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0px;}
        .grade-value { font-size: 48px; font-weight: 800; color: #fff; line-height: 1; text-shadow: 0 0 20px rgba(255,255,255,0.1); }
        .grade-desc { font-size: 11px; font-weight: bold; margin-top: 4px; padding: 2px 8px; border-radius: 4px; background: #333; color: #ccc;}

        .metrics-section { flex: 1; padding: 12px 20px; display: flex; flex-direction: column; justify-content: center; gap: 8px; }
        .metric-row { display: flex; align-items: center; justify-content: space-between; font-size: 12px; }
        .metric-label { width: 90px; color: #aaa; text-align: right; margin-right: 10px;}
        .metric-bar-bg { flex: 1; height: 6px; background: #222; border-radius: 3px; overflow: hidden; margin-right: 10px; position: relative;}
        .metric-bar-fill { height: 100%; width: 0%; background: #555; transition: width 0.3s, background 0.3s; }
        .metric-val { width: 60px; text-align: right; font-family: 'Consolas', monospace; font-weight: bold; color: #eee; }

        .advice-section {
            width: 160px; padding: 12px; background: rgba(0,0,0,0.2);
            border-left: 1px solid #333; display: flex; flex-direction: column; justify-content: center;
        }
        .advice-title { font-size: 10px; color: #666; font-weight: bold; margin-bottom: 5px; display: flex; align-items: center;}
        .advice-content { font-size: 11px; color: #ccc; line-height: 1.4; }

        .color-s { color: #00ffaa !important; }
        .color-a { color: #22ff22 !important; }
        .color-b { color: #00ccff !important; }
        .color-c { color: #ffaa00 !important; }
        .color-d { color: #ff4444 !important; }
        .bg-s { background: #00ffaa !important; }
        .bg-a { background: #22ff22 !important; }
        .bg-b { background: #00ccff !important; }
        .bg-c { background: #ffaa00 !important; }
        .bg-d { background: #ff4444 !important; }

        /* Âè≥‰æßÈù¢Êùø */
        #ui-panel {
            position: absolute; top: 130px; right: 20px; width: 260px;
            background: rgba(20, 20, 25, 0.9); color: #eee; padding: 15px;
            border-radius: 6px; border: 1px solid #333; backdrop-filter: blur(10px);
            user-select: none; max-height: 75vh; overflow-y: auto;
            z-index: 25;
        }
        .panel-section { margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 15px; }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .sec-title { font-size: 11px; color: #666; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; }
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 12px;}
        .control-row label { width: 60px; color: #aaa; }
        input[type=range] { -webkit-appearance: none; flex: 1; margin: 0 10px; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%;
            background: #888; cursor: pointer; margin-top: -4px; border: 2px solid #111;
        }
        input[type=range]:hover::-webkit-slider-thumb { background: #ff9900; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; border-radius: 2px; }
        .nudge-btn {
            background: #2a2a30; border: 1px solid #444; color: #ccc; width: 20px; height: 20px;
            border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 12px; line-height: 1;
        }
        .nudge-btn:hover { background: #ff9900; color: #000; }
        .val-text { width: 35px; text-align: right; font-family: 'Consolas', monospace; color: #ff9900; font-size: 11px;}

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #ff9900; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.0/build/index.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text" style="color:#666; font-size:14px; margin-top:15px">Ê≠£Âú®Âä†ËΩΩÊ®°ÂûãËµÑÊ∫ê...</div>
        <div id="loader-hint" style="color:#666; font-size:12px; margin-top:10px; text-align:center; display:none">
            Âä†ËΩΩÊó∂Èó¥ËæÉÈïø...<br>ËØ∑Á°Æ‰øùÊñá‰ª∂Â§πÂÜÖÊúâ "car_model.obj"
        </div>
    </div>

    <div id="header">
        <div class="brand-group">
            <div style="width:8px; height:8px; background:#ff9900; border-radius:50%; margin-right:10px;"></div>
            <span style="font-weight:bold; color:#ccc">ACOUSTIC SIM</span>
            <span style="color:#ff0000; font-weight:bold; margin-left:8px;">V13.5</span>
            <span class="version-tag">Online</span>
        </div>
        
        <div class="header-btns">
            <div class="btn-tool" onclick="exportToRhino()" id="btn-export">
                <span style="margin-right:5px">üìã</span> Â§çÂà∂ Rhino Êï∞ÊçÆ
            </div>
            <div class="btn-tool" onclick="fitCamera()">ËßÜËßíÂ§ç‰Ωç</div>
        </div>
    </div>

    <!-- ‰ª™Ë°®Áõò -->
    <div id="hud-dashboard">
        <div class="grade-section">
            <div class="grade-title">Â£∞Âú∫ËØÑÁ∫ß</div>
            <div class="grade-value" id="grade-letter">--</div>
            <div class="grade-desc" id="grade-desc">READY</div>
        </div>
        <div class="metrics-section">
            <div class="metric-row">
                <div class="metric-label">Áõ¥ËææÂ£∞ÂÆåÊï¥Â∫¶</div>
                <div class="metric-bar-bg"><div class="metric-bar-fill" id="bar-direct" style="width: 0%;"></div></div>
                <div class="metric-val" id="val-direct">--</div>
            </div>
            <div class="metric-row">
                <div class="metric-label">ÂèçÂ∞ÑÂπ≤Êâ∞Âº∫Â∫¶</div>
                <div class="metric-bar-bg"><div class="metric-bar-fill" id="bar-refl" style="width: 0%;"></div></div>
                <div class="metric-val" id="val-refl">--</div>
            </div>
            <div class="metric-row">
                <div class="metric-label">Á¨¨‰∏ÄÈô∑Ê≥¢È¢ëÁéá</div>
                <div style="flex:1; text-align:left; color:#666; font-size:11px; margin-right:10px;">(Null Frequency)</div>
                <div class="metric-val" id="val-freq">--</div>
            </div>
        </div>
        <div class="advice-section">
            <div class="advice-title"><span style="width:6px; height:6px; background:#ff9900; border-radius:50%; margin-right:6px;"></span>AI DIAGNOSIS</div>
            <div class="advice-content" id="advice-text">ÁÆóÊ≥ïÂ∑≤Â∞±Áª™„ÄÇ<br>ËØ∑Ë∞ÉÊï¥‰ΩçÁΩÆÔºåÊª°ÊÑèÂêéÁÇπÂáªÂ§çÂà∂Êï∞ÊçÆÂà∞ÁäÄÁâõ„ÄÇ</div>
        </div>
    </div>

    <div id="ui-panel">
        <div class="panel-section">
            <div class="sec-title">‰ΩçÁΩÆË∞ÉÊï¥ <span>Position</span></div>
            <div class="control-row">
                <label>X (Â∑¶Âè≥)</label>
                <button class="nudge-btn" onclick="adjPos('x', -0.005)">‚Äπ</button>
                <input type="range" min="-1.0" max="1.0" step="0.001" id="pos-x-slider">
                <button class="nudge-btn" onclick="adjPos('x', 0.005)">‚Ä∫</button>
            </div>
            <div class="control-row">
                <label>Y (È´ò‰Ωé)</label>
                <button class="nudge-btn" onclick="adjPos('y', -0.005)">‚Äπ</button>
                <input type="range" min="0.0" max="2.0" step="0.001" id="pos-y-slider">
                <button class="nudge-btn" onclick="adjPos('y', 0.005)">‚Ä∫</button>
            </div>
            <div class="control-row">
                <label>Z (ÂâçÂêé)</label>
                <button class="nudge-btn" onclick="adjPos('z', -0.005)">‚Äπ</button>
                <input type="range" min="-1.5" max="1.5" step="0.001" id="pos-z-slider">
                <button class="nudge-btn" onclick="adjPos('z', 0.005)">‚Ä∫</button>
            </div>
        </div>

        <div class="panel-section">
            <div class="sec-title">ËßíÂ∫¶ÂßøÊÄÅ <span>Orientation</span></div>
            <div class="control-row">
                <label>Ê∞¥Âπ≥ÊåáÂêë</label>
                <button class="nudge-btn" onclick="adj('pan', -1)">‚Äπ</button>
                <input type="range" min="-180" max="180" id="pan-slider">
                <button class="nudge-btn" onclick="adj('pan', 1)">‚Ä∫</button>
                <span class="val-text" id="pan-val">--</span>
            </div>
            <div class="control-row">
                <label>ÂûÇÁõ¥‰øØ‰ª∞</label>
                <button class="nudge-btn" onclick="adj('tilt', -0.5)">‚Äπ</button>
                <input type="range" min="-10" max="80" step="0.5" id="tilt-slider">
                <button class="nudge-btn" onclick="adj('tilt', 0.5)">‚Ä∫</button>
                <span class="val-text" id="tilt-val">--</span>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="sec-title">ÂçïÂÖÉÁâπÊÄß <span>Physics</span></div>
            <div class="control-row">
                <label>Êâ©Êï£Ëßí</label>
                <input type="range" min="15" max="140" id="disp-slider">
                <span class="val-text" id="disp-val">--</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';

        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;

        const CONFIG = {
            carRotationX: Math.PI / 2, 
            carOffsetY: 1.5,
            initPos: { x: -0.33, y: 1.45, z: -0.05 },
            initOri: { pan: 22, tilt: 4 },
            initAngle: 60,  
            rayCount: 2000, 
            listenerRadius: 0.15, 
            listenerCoords: new THREE.Vector3(-0.3972, 0.5852, -0.0752) 
        };

        let camera, scene, renderer, orbit;
        let carWrapper; 
        let tweeterRoot, tweeterMesh, soundCone;
        let heatmapSystem, laserLines;
        let raycaster;
        let environmentObjects = [];
        let listenerZone = null;
        let localRayDirs = []; 
        let directSoundOccluded = false;

        const matBody = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7, metalness: 0.1, side: THREE.DoubleSide });
        const matGlass = new THREE.MeshPhysicalMaterial({ color: 0xaaccff, transmission: 0.9, opacity: 0.2, roughness: 0.05, metalness: 0.1, side: THREE.DoubleSide, transparent: true, depthWrite: false });
        const matGhost = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.15, wireframe: true, depthWrite: false, side: THREE.DoubleSide });
        const matZone = new THREE.MeshBasicMaterial({ color: 0x22ff22, transparent: true, opacity: 0.4 });

        const state = {
            pan: CONFIG.initOri.pan, 
            tilt: CONFIG.initOri.tilt, 
            angle: CONFIG.initAngle, 
            distance: 1.5, 
            pos: { ...CONFIG.initPos }
        };

        function getSeverityColor(ratio) {
            const r = THREE.MathUtils.clamp(ratio, 0, 0.5);
            if(r <= 0.10) return new THREE.Color(0x22ff22); 
            else if(r < 0.25) {
                const t = (r - 0.10) / 0.15;
                return new THREE.Color(0x22ff22).lerp(new THREE.Color(0xffff00), t);
            } else {
                const t = Math.min((r - 0.25) / 0.20, 1.0);
                return new THREE.Color(0xffff00).lerp(new THREE.Color(0xff2222), t);
            }
        }

        window.adj = (key, delta) => {
            const el = document.getElementById(key + '-slider');
            el.value = parseFloat(el.value) + delta;
            el.dispatchEvent(new Event('input'));
        };
        window.adjPos = (axis, delta) => {
            const el = document.getElementById(`pos-${axis}-slider`);
            el.value = parseFloat(el.value) + delta;
            el.dispatchEvent(new Event('input'));
        };
        window.fitCamera = () => {
            if(!carWrapper) return;
            const box = new THREE.Box3().setFromObject(carWrapper);
            if(box.isEmpty()) return;
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.copy(center.clone().add(new THREE.Vector3(1, 0.8, 1.2).multiplyScalar(maxDim * 1.2)));
            camera.lookAt(center);
            orbit.target.copy(center);
            orbit.update();
        };

        window.exportToRhino = () => {
            const btn = document.getElementById('btn-export');
            
            if (!listenerZone || !tweeterMesh || !soundCone) {
                alert("Âú∫ÊôØÊú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïÂØºÂá∫");
                return;
            }

            const ptEar = new THREE.Vector3();
            listenerZone.getWorldPosition(ptEar);
            
            tweeterMesh.updateMatrixWorld();
            const ptTweet = new THREE.Vector3();
            tweeterMesh.getWorldPosition(ptTweet);

            const dir = new THREE.Vector3(0, 0, 1)
                .applyQuaternion(tweeterMesh.quaternion)
                .normalize();
                
            const ptAim = ptTweet.clone().add(dir.multiplyScalar(1.0));

            const toRhino = (p) => {
                const x = (p.x - ptEar.x) * 1000;
                const y = (p.y - ptEar.y) * 1000;
                const z = (p.z - ptEar.z) * 1000;
                return `w${x.toFixed(3)},${(-z).toFixed(3)},${y.toFixed(3)}`;
            };

            const strEar = "w0,0,0";
            const strTweet = toRhino(ptTweet);
            const strAim = toRhino(ptAim);

            const cmd = `! _NoEcho _SelNone _Polyline ${strEar} ${strTweet} ${strAim} _Enter _SelLast _Explode _SelLast _Group _Move ${strEar}`; 

            navigator.clipboard.writeText(cmd.replace(/\n/g, " ")).then(() => {
                const originalHtml = btn.innerHTML;
                btn.innerHTML = "<span style='color:#4f4; font-weight:bold'>‚úî Â∞±Áª™</span>";
                btn.classList.add('btn-active');
                
                const advice = document.getElementById('advice-text');
                advice.innerHTML = `
                    <strong style="color:#4f4">üìã Êï∞ÊçÆÂ∑≤ÁîüÊàê</strong><br>
                    1. Âú® Rhino ËßÜÂè£Êåâ <span style="color:#fff; background:#444; padding:0 4px">Ctrl+V</span><br>
                    2. <span style="color:#aaf">‰∫∫ËÄ≥‰ΩçÁΩÆ</span>Âç≥‰∏∫ÂéüÁÇπ<br>
                    3. ÊåáÂêëÂ∑≤ÂÆåÊàêÈïúÂÉèÊ†°ÂáÜ
                `;

                setTimeout(() => {
                    btn.innerHTML = originalHtml;
                    btn.classList.remove('btn-active');
                }, 4000);
            }).catch(err => {
                alert("Â§çÂà∂Â§±Ë¥•: " + err);
            });
        };

        function generateFibonacciPoints(count, coneAngleDeg) {
            const points = [];
            const goldenRatio = (1 + Math.sqrt(5)) / 2;
            const coneAngleRad = THREE.MathUtils.degToRad(coneAngleDeg / 2); 
            for (let i = 0; i < count; i++) {
                const k = i + 0.5;
                const phi = Math.acos(1 - (1 - Math.cos(coneAngleRad)) * (k / count));
                const theta = 2 * Math.PI * k / goldenRatio;
                points.push(new THREE.Vector3(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi)));
            }
            return points;
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.5)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a20);
            scene.add(new THREE.GridHelper(10, 20, 0x444444, 0x222222));
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dir = new THREE.DirectionalLight(0xffffff, 1.5);
            dir.position.set(3, 8, 3); scene.add(dir);

            createTweeterSystem();
            initVisuals(); 

            orbit = new OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;
            raycaster = new THREE.Raycaster();

            loadCarModelWithFallback();
            setupUIEvents();
            window.addEventListener('resize', onResize);
            localRayDirs = generateFibonacciPoints(CONFIG.rayCount, state.angle);
            animate();
        }

        function loadCarModelWithFallback() {
            const loader = new OBJLoader();
            let loadSuccess = false;
            
            // ÊèêÁ§∫Áî®Êà∑Ê≠£Âú®Âä†ËΩΩ
            const hintTimer = setTimeout(() => {
                document.getElementById('loader-hint').style.display = 'block';
            }, 2000);

            // Â§±Ë¥•Êó∂ÁöÑÂ§ÑÁêÜÔºöÂä†ËΩΩËôöÊãüÁéØÂ¢É
            const onFail = (err) => {
                console.warn("Âä†ËΩΩÂ§±Ë¥•ÔºåÂêØÁî®ËôöÊãüÁéØÂ¢É", err);
                clearTimeout(hintTimer);
                document.getElementById('loader-hint').innerText = "Êú™ÊâæÂà∞Ê®°ÂûãÊñá‰ª∂ÔºåÂä†ËΩΩÊºîÁ§∫Ê®°Âºè...";
                setTimeout(createDummyEnvironment, 500);
            };

            // ËøôÈáåÁöÑË∑ØÂæÑ './car_model.obj' ‰ª£Ë°®ÂΩìÂâçÊñá‰ª∂Â§π
            loader.load('./car_model.obj', (root) => {
                loadSuccess = true;
                clearTimeout(hintTimer);
                setupCarModel(root);
            }, 
            // ËøõÂ∫¶
            (xhr) => {
                if(xhr.total > 0) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    document.getElementById('loader-text').innerText = `Âä†ËΩΩÊ®°Âûã‰∏≠... ${percent}%`;
                }
            }, 
            onFail);
        }

        function createDummyEnvironment() {
            const dummyRoot = new THREE.Group();
            const dash = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.5, 0.8), matBody);
            dash.position.set(0, 0.8, 0.9); dash.name = "dummy_dash"; dummyRoot.add(dash);
            const glassFront = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.9), matGlass);
            glassFront.position.set(0, 1.35, 1.1); glassFront.rotation.x = -Math.PI/3; glassFront.name = "dummy_glass_front"; dummyRoot.add(glassFront);
            const glassSide = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.5), matGlass);
            glassSide.position.set(-0.75, 1.3, 0.2); glassSide.rotation.y = Math.PI/2; glassSide.rotation.z = Math.PI/6; glassSide.name = "dummy_glass_side"; dummyRoot.add(glassSide);
            setupCarModel(dummyRoot);
        }

        function setupCarModel(root) {
            if(carWrapper) scene.remove(carWrapper);
            carWrapper = new THREE.Group();
            scene.add(carWrapper);

            if(root.children.length > 0 && root.children[0].geometry) {
                 const box = new THREE.Box3().setFromObject(root);
                 const sz = box.getSize(new THREE.Vector3());
                 if(sz.x > 50) root.scale.set(0.001, 0.001, 0.001);
            }
            root.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(root);
            const center = box.getCenter(new THREE.Vector3());
            root.position.sub(center);
            carWrapper.add(root);
            
            if(!root.name.includes("dummy")) {
               carWrapper.rotation.x = CONFIG.carRotationX; 
               carWrapper.position.y = CONFIG.carOffsetY;
            }

            environmentObjects = [];
            root.traverse(c => {
                if(c.isMesh) {
                    const n = c.name.toLowerCase();
                    if(n.includes('glass') || n.includes('window') || n.includes('boli')) {
                        c.material = matGlass;
                        c.userData.acoustics = { reflectivity: 0.92, type: 'glass' };
                        environmentObjects.push(c);
                    } else if(n.includes('head') || n.includes('ear') || n.includes('listener')) {
                        c.material = matGhost;
                        c.visible = true; 
                    } else if (!n.includes('dummy')) { 
                        c.material = matBody;
                        c.userData.acoustics = { reflectivity: 0.55, type: 'body' };
                        environmentObjects.push(c);
                    }
                    if(c.geometry) c.geometry.computeBoundsTree();
                }
            });

            const zoneGeo = new THREE.SphereGeometry(CONFIG.listenerRadius, 32, 32);
            listenerZone = new THREE.Mesh(zoneGeo, matZone);
            listenerZone.position.copy(CONFIG.listenerCoords);
            listenerZone.name = "sensor_sweet_spot";
            carWrapper.add(listenerZone);

            document.getElementById('loader').style.display = 'none';

            ['x','y','z'].forEach(k => {
                const el = document.getElementById(`pos-${k}-slider`);
                el.value = state.pos[k];
                if(state.pos[k] < parseFloat(el.min)) el.min = state.pos[k] - 0.5;
                if(state.pos[k] > parseFloat(el.max)) el.max = state.pos[k] + 0.5;
            });

            window.fitCamera();
            updateTweeterTransform(); 
        }

        function createTweeterSystem() {
            tweeterRoot = new THREE.Group();
            scene.add(tweeterRoot);
            tweeterMesh = new THREE.Group(); 
            tweeterRoot.add(tweeterMesh);    

            const casing = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.03, 0.03, 32).rotateX(Math.PI/2).translate(0, 0, -0.015), new THREE.MeshStandardMaterial({ color: 0xff9900, metalness: 0.5, roughness: 0.2 }));
            tweeterMesh.add(casing);
            const dome = new THREE.Mesh(new THREE.SphereGeometry(0.022, 32, 16, 0, Math.PI*2, 0, Math.PI/2).rotateX(Math.PI/2), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3 }));
            tweeterMesh.add(dome);
            const coneGeo = new THREE.CylinderGeometry(1, 0.001, 1, 32, 1, true);
            coneGeo.translate(0, 0.5, 0); coneGeo.rotateX(Math.PI/2); 
            const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createLinearGradient(0,0,0,64); g.addColorStop(0,'rgba(0,220,255,0)'); g.addColorStop(1,'rgba(0,220,255,0.15)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            soundCone = new THREE.Mesh(coneGeo, new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false }));
            tweeterMesh.add(soundCone);
        }

        function updateTweeterTransform() {
            tweeterRoot.position.set(state.pos.x, state.pos.y, state.pos.z);
            tweeterMesh.rotation.order = 'YXZ'; 
            tweeterMesh.rotation.y = THREE.MathUtils.degToRad(state.pan);
            tweeterMesh.rotation.x = THREE.MathUtils.degToRad(-state.tilt);
            
            const r = state.distance * Math.tan(THREE.MathUtils.degToRad(state.angle/2));
            soundCone.scale.set(r, r, state.distance);
            localRayDirs = generateFibonacciPoints(CONFIG.rayCount, state.angle);
            updateSimulation();
        }

        function initVisuals() {
            const maxP = CONFIG.rayCount * 2; 
            const pGeo = new THREE.BufferGeometry();
            pGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(maxP*3), 3));
            pGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(maxP*3), 3));
            heatmapSystem = new THREE.Points(pGeo, new THREE.PointsMaterial({ size: 0.02, map: createGlowTexture(), vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false }));
            heatmapSystem.frustumCulled = false; scene.add(heatmapSystem);

            const lGeo = new THREE.BufferGeometry();
            lGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(maxP*6), 3)); 
            lGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(maxP*6), 3));
            laserLines = new THREE.LineSegments(lGeo, new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.3 }));
            laserLines.frustumCulled = false; scene.add(laserLines);
        }

        function setupUIEvents() {
            const bind = (id, key, suffix='¬∞') => {
                const el = document.getElementById(id);
                document.getElementById(id.replace('slider', 'val')).innerText = state[key] + suffix;
                el.oninput = function() {
                    state[key] = parseFloat(this.value);
                    document.getElementById(id.replace('slider', 'val')).innerText = this.value + suffix;
                    updateTweeterTransform();
                };
            };
            bind('pan-slider', 'pan');
            bind('tilt-slider', 'tilt');
            bind('disp-slider', 'angle');
            ['x','y','z'].forEach(axis => {
                const el = document.getElementById(`pos-${axis}-slider`);
                el.oninput = function() {
                    state.pos[axis] = parseFloat(this.value);
                    updateTweeterTransform();
                };
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateSimulation();
        }

        function getRayPointDist(rayOrigin, rayDir, point) {
            const v = new THREE.Vector3().subVectors(point, rayOrigin);
            const t = v.dot(rayDir); 
            if (t < 0) return { dist: Infinity, point: rayOrigin.clone(), t: t }; 
            const closestPoint = rayOrigin.clone().add(rayDir.clone().multiplyScalar(t));
            return { dist: closestPoint.distanceTo(point), point: closestPoint, t: t };
        }

        function updateSimulation() {
            if(!environmentObjects.length) return;

            tweeterMesh.updateMatrixWorld();
            const origin = new THREE.Vector3(); tweeterMesh.getWorldPosition(origin);
            const quat = tweeterMesh.getWorldQuaternion(new THREE.Quaternion());
            
            let listenerPos = new THREE.Vector3();
            if(listenerZone) listenerZone.getWorldPosition(listenerPos);
            else listenerPos.copy(CONFIG.listenerCoords); 

            let directDist = origin.distanceTo(listenerPos);
            let theoreticalDirectSpl = 1.0 / (directDist * directDist);
            
            raycaster.set(origin, listenerPos.clone().sub(origin).normalize());
            raycaster.far = directDist - 0.05; 
            const occHits = raycaster.intersectObjects(environmentObjects, false);
            directSoundOccluded = (occHits.length > 0);

            const halfAngleRad = THREE.MathUtils.degToRad(state.angle / 2);
            let dispersionExp = 1;
            const cosHalf = Math.cos(halfAngleRad);
            if(cosHalf > 0 && cosHalf < 0.999) dispersionExp = Math.log(0.5) / Math.log(cosHalf);
            dispersionExp = THREE.MathUtils.clamp(dispersionExp, 0.5, 50);

            const posArr = heatmapSystem.geometry.attributes.position.array;
            const colArr = heatmapSystem.geometry.attributes.color.array;
            const linePos = laserLines.geometry.attributes.position.array;
            const lineCol = laserLines.geometry.attributes.color.array;
            const colLine = new THREE.Color(0x00aaff); 

            let hitCount = 0;
            let maxRiskRatio = 0;
            let worstPathDiff = 0;

            for(let i=0; i<localRayDirs.length; i++) {
                const localDir = localRayDirs[i];
                if(localDir.z <= 0) continue; 

                const dir = localDir.clone().applyQuaternion(quat).normalize();
                const offAxisFactor = Math.pow(localDir.z, dispersionExp); 
                if(offAxisFactor < 0.01) continue; 

                raycaster.set(origin, dir);
                raycaster.far = 3.5; 
                const hits = raycaster.intersectObjects(environmentObjects, false);
                
                if(hits.length > 0) {
                    const hit = hits[0];
                    const hitPt = hit.point;
                    const d1 = hit.distance;
                    const reflectivity = hit.object.userData.acoustics ? hit.object.userData.acoustics.reflectivity : 0.5;

                    const I = dir.clone();
                    let N = hit.face.normal.clone().applyQuaternion(hit.object.getWorldQuaternion(new THREE.Quaternion())).normalize();
                    if (I.dot(N) > 0) N.negate(); 
                    const R = I.clone().sub(N.clone().multiplyScalar(2 * I.dot(N))).normalize();

                    const calc = getRayPointDist(hitPt, R, listenerPos);
                    
                    if (calc.dist < CONFIG.listenerRadius && calc.t > 0) {
                        const d2 = calc.t; 
                        const totalDist = d1 + d2;
                        const weight = Math.cos(calc.dist / CONFIG.listenerRadius * Math.PI / 2); 
                        
                        const reflectedSpl = (1.0 / (totalDist * totalDist)) * offAxisFactor * reflectivity * weight;
                        const ratio = reflectedSpl / theoreticalDirectSpl;

                        if (ratio > maxRiskRatio) {
                            maxRiskRatio = ratio;
                            worstPathDiff = totalDist - directDist;
                        }

                        if (ratio > 0.05) {
                            posArr[hitCount*3] = hitPt.x; posArr[hitCount*3+1] = hitPt.y; posArr[hitCount*3+2] = hitPt.z;
                            const dotColor = getSeverityColor(ratio);
                            colArr[hitCount*3] = dotColor.r; colArr[hitCount*3+1] = dotColor.g; colArr[hitCount*3+2] = dotColor.b;
                            linePos[hitCount*6] = origin.x; linePos[hitCount*6+1] = origin.y; linePos[hitCount*6+2] = origin.z;
                            linePos[hitCount*6+3] = hitPt.x; linePos[hitCount*6+4] = hitPt.y; linePos[hitCount*6+5] = hitPt.z;
                            lineCol[hitCount*6] = colLine.r; lineCol[hitCount*6+1] = colLine.g; lineCol[hitCount*6+2] = colLine.b;
                            lineCol[hitCount*6+3] = colLine.r; lineCol[hitCount*6+4] = colLine.g; lineCol[hitCount*6+5] = colLine.b;
                            hitCount++;
                        }
                    }
                }
            }

            if(listenerZone) {
                const targetColor = getSeverityColor(maxRiskRatio);
                listenerZone.material.color.lerp(targetColor, 0.1);
                listenerZone.material.opacity = THREE.MathUtils.lerp(listenerZone.material.opacity, 0.2 + maxRiskRatio * 1.5, 0.1);
            }

            for(let k=hitCount*3; k<posArr.length; k++) posArr[k] = 0;
            for(let k=hitCount*6; k<linePos.length; k++) linePos[k] = 0;
            heatmapSystem.geometry.setDrawRange(0, hitCount);
            heatmapSystem.geometry.attributes.position.needsUpdate = true;
            heatmapSystem.geometry.attributes.color.needsUpdate = true;
            laserLines.geometry.setDrawRange(0, hitCount * 2);
            laserLines.geometry.attributes.position.needsUpdate = true;
            laserLines.geometry.attributes.color.needsUpdate = true;

            updateDashboard(maxRiskRatio, worstPathDiff);
        }

        function updateDashboard(maxRatio, pathDiff) {
            const elLetter = document.getElementById('grade-letter');
            const elDesc = document.getElementById('grade-desc');
            const barDirect = document.getElementById('bar-direct');
            const valDirect = document.getElementById('val-direct');
            const barRefl = document.getElementById('bar-refl');
            const valRefl = document.getElementById('val-refl');
            const valFreq = document.getElementById('val-freq');
            const elAdvice = document.getElementById('advice-text');

            if (directSoundOccluded) {
                barDirect.style.width = "40%"; barDirect.className = "metric-bar-fill bg-c"; 
                valDirect.innerText = "BLOCK"; valDirect.className = "metric-val color-c";
            } else {
                barDirect.style.width = "100%"; barDirect.className = "metric-bar-fill bg-a"; 
                valDirect.innerText = "OK"; valDirect.className = "metric-val color-a";
            }

            const p = Math.min(maxRatio * 100, 100).toFixed(1);
            valRefl.innerText = p + "%";
            barRefl.style.width = Math.min(maxRatio * 300, 100) + "%"; 
            
            let freqStr = "--";
            if (maxRatio > 0.05 && pathDiff > 0) {
                const f = 343 / (2 * pathDiff);
                freqStr = (f > 20000) ? ">20k" : Math.round(f) + " Hz";
            }
            valFreq.innerText = freqStr;

            let grade = 'A';
            let desc = 'GOOD';
            let gClass = 'color-a';
            let advice = "";

            if (maxRatio <= 0.08) {
                grade = 'S'; desc = 'REFERENCE'; gClass = 'color-s';
                barRefl.className = "metric-bar-fill bg-s";
                advice = "‚úÖ ÂÆåÁæéÂ£∞Âú∫ÔºöÂèçÂ∞ÑËÉΩÈáèÊûÅ‰ΩéÔºåÁªìÂÉèÂ∞ÜÈùûÂ∏∏Ê∏ÖÊô∞ÈîêÂà©„ÄÇ";
            } else if (maxRatio <= 0.18) {
                grade = 'A'; desc = 'EXCELLENT'; gClass = 'color-a';
                barRefl.className = "metric-bar-fill bg-a";
                advice = "‚ú® ‰ºòÁßÄË°®Áé∞ÔºöÂèçÂ∞ÑÊéßÂà∂ÂæóÂΩìÔºåÂ±û‰∫éÈ´òÊ∞¥ÂáÜÂÄíÊ®°Â∑•Ëâ∫„ÄÇ";
            } else if (maxRatio <= 0.30) {
                grade = 'B'; desc = 'STANDARD'; gClass = 'color-b';
                barRefl.className = "metric-bar-fill bg-b";
                advice = "üÜó Ë°å‰∏öÊ†áÂáÜÔºöÂ≠òÂú®Â∏∏ËßÑÂèçÂ∞Ñ„ÄÇÂª∫ËÆÆÂæÆË∞ÉËßíÂ∫¶Â∞ùËØïÈôç‰ΩéÂπ≤Êâ∞„ÄÇ";
            } else {
                grade = 'C'; desc = 'RISK'; gClass = 'color-d';
                barRefl.className = "metric-bar-fill bg-d";
                advice = `‚ö†Ô∏è ÂèçÂ∞ÑËøáÂº∫Ôºö${freqStr} Â§ÑÂèØËÉΩÊúâ‰∏•ÈáçÂπ≤Ê∂â„ÄÇËØ∑Â§ßÂπÖË∞ÉÊï¥ËßíÂ∫¶ÈÅøÂºÄÁéªÁíÉ/‰ª™Ë°®Âè∞„ÄÇ`;
            }

            if (directSoundOccluded && grade !== 'C') {
                advice = "‚ö†Ô∏è Ê≥®ÊÑèÔºöÂΩìÂâçËßíÂ∫¶ËôΩÁÑ∂ÂèçÂ∞ÑÊéßÂà∂ËâØÂ•Ω(S/A/B)Ôºå‰ΩÜÁõ¥ËææÂ£∞Ë¢´ÈÅÆÊå°„ÄÇ";
            }

            elLetter.innerText = grade;
            elLetter.className = `grade-value ${gClass}`;
            elDesc.innerText = desc;
            elDesc.className = `grade-desc bg-${gClass.replace('color-', '')}`;
            elDesc.style.color = '#000';
            elAdvice.innerText = advice;
        }

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>